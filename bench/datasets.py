import os
import re


# =========================================================
# HELPER: Robust Line Splitter
# =========================================================
def split_line_robust(line):
    """
    Splits a line into (path, label).
    Handles paths with spaces by checking if the last token is an integer.
    """
    line = line.strip()
    parts = line.split()

    if len(parts) < 2:
        # Case: "path/to/image.jpg" (No label)
        return line, -1

    # Check if the last part is a label (integer)
    try:
        label = int(parts[-1])
        # Join all previous parts to form the path (handling spaces)
        path = " ".join(parts[:-1])
        return path, label
    except ValueError:
        # Last part is not an integer?
        # Assume the whole line is the path and there is no label.
        return line, -1


# =========================================================
# 1. PARSERS
# =========================================================

def parse_ln_manifest(line, root):
    """
    Parses LN v2. Handles two formats:
    A. Rich Manifest (5 cols): relative_path label level parce nuisance
    B. Simple List (2 cols):   nuisance/level/filename label
    """
    parts = line.strip().split()

    # Format A: Rich Manifest (Generated by generate_ln.py)
    # We assume generated paths do NOT have spaces.
    if len(parts) >= 5 and parts[1].isdigit() and parts[2].isdigit():
        return {
            'path': parts[0],
            'label': int(parts[1]),
            'level': int(parts[2]),
            'parce': float(parts[3]),
            'nuisance': parts[4]
        }

    # Format B: Folder Structure (Standard ImageList)
    path, label = split_line_robust(line)

    # Heuristic: Parse nuisance/level from path structure
    # Example: blur/1/img.png -> level=1, nuisance=blur
    path_parts = path.replace('\\', '/').split('/')
    level = 0
    nuisance = "unknown_ln"

    for i, p in enumerate(path_parts):
        # Look for the single digit folder "1" to "5"
        if p.isdigit() and 1 <= int(p) <= 5:
            level = int(p)
            if i > 0:
                nuisance = path_parts[i - 1]
            break

    return {
        'path': path,
        'label': label,
        'level': level,
        'parce': -1.0,
        'nuisance': nuisance
    }


def parse_imagenet_c(line, root):
    """
    Parses ImageNet-C.
    Snippet: imagenet_c/contrast/4/ILSVRC.JPEG 0
    Structure: [optional_root]/nuisance/level/filename
    """
    path, label = split_line_robust(line)
    path_parts = path.replace('\\', '/').split('/')

    level = 0
    nuisance = "unknown_c"

    # Heuristic: Find the folder that is a single digit 1-5
    for i, p in enumerate(path_parts):
        if p.isdigit() and 1 <= int(p) <= 5:
            level = int(p)
            if i > 0:
                nuisance = path_parts[i - 1]
            break

    return {
        'path': path,
        'label': label,
        'level': level,
        'parce': -1.0,
        'nuisance': nuisance
    }


def parse_cns_benchmark(line, root):
    """
    Parses CNS.
    Snippet: painting_style/004_hammerhead/seed_0040_scale_2500.jpg 4
    Structure: nuisance/class/filename (severity in filename)
    """
    path, label = split_line_robust(line)
    path_parts = path.replace('\\', '/').split('/')

    # Nuisance is usually the top-level folder
    nuisance = path_parts[0] if len(path_parts) > 0 else "cns_unknown"

    # Extract severity from filename: scale_2500 -> Level 5
    level = 0
    match = re.search(r'scale_(\d+)', path)
    if match:
        raw = int(match.group(1))
        # Map raw scale (0-3000+) to approximate levels 1-5
        if raw == 0:
            level = 0
        elif raw < 500:
            level = 1
        elif raw < 1000:
            level = 2
        elif raw < 1500:
            level = 3
        elif raw < 2000:
            level = 4
        else:
            level = 5

    return {
        'path': path,
        'label': label,
        'level': level,
        'parce': -1.0,
        'nuisance': nuisance
    }


def parse_standard_ood(line, root):
    """
    Parses standard OOD lists (ImageNet-O, iNaturalist).
    Format: path label
    """
    path, label = split_line_robust(line)
    return {
        'path': path,
        'label': label,
        'level': 0,
        'parce': -1.0,
        'nuisance': 'clean_ood'  # Will be overwritten by dataset name
    }
# =========================================================
# 2. DATASET REGISTRY
# =========================================================

# You can change these roots to match your server layout
DATA_ROOT_DEFAULT = "data/images_largescale"
LIST_ROOT_DEFAULT = "data/benchmark_imglist"

DATASET_ZOO = {
    # --- YOUR DATASET ---
    "LN_v2": {
        "root": f"{DATA_ROOT_DEFAULT}/imagenet_ln_v2",
        "imglist": f"{LIST_ROOT_DEFAULT}/imagenet_ln/imagenet_ln_v2.txt",
        "parser": parse_ln_manifest
    },

    # --- ID DATASETS ---
    "ImageNet-Val": {
        "root": f"{DATA_ROOT_DEFAULT}",
        "imglist": f"{LIST_ROOT_DEFAULT}/imagenet/val_imagenet.txt",
        "parser": parse_standard_ood
    },

    # --- ROBUSTNESS BENCHMARKS ---
    "ImageNet-C": {
        "root": f"{DATA_ROOT_DEFAULT}",
        "imglist": f"{LIST_ROOT_DEFAULT}/imagenet/test_imagenet_c.txt",  # Assumes you concat lists
        "parser": parse_imagenet_c
    },

    "CNS": {
        "root": f"{DATA_ROOT_DEFAULT}/cns",
        "imglist": f"{LIST_ROOT_DEFAULT}/cns_bench/cns_bench_all.txt",
        "parser": parse_cns_benchmark
    },

    # --- OOD BENCHMARKS ---
    "ImageNet-O": {
        "root": f"{DATA_ROOT_DEFAULT}/imagenet_o",
        "imglist": f"{LIST_ROOT_DEFAULT}/imagenet_o/test_imagenet_o.txt",
        "parser": parse_standard_ood
    },
    "iNaturalist": {
        "root": f"{DATA_ROOT_DEFAULT}/inaturalist",
        "imglist": f"{LIST_ROOT_DEFAULT}/imagenet/test_inaturalist.txt",
        "parser": parse_standard_ood
    }
}


def get_dataset_config(name):
    if name not in DATASET_ZOO:
        raise ValueError(f"Dataset '{name}' not found in DATASET_ZOO. Available: {list(DATASET_ZOO.keys())}")
    return DATASET_ZOO[name]